---
title: "【软件测试理论基础】01-软件测试基础知识"
date: 2022-04-01T12:19:24+08:00
draft: false
author: ""
description: "软件测试-理论基础"
images: []

tags: ["软件测试","软件测试定义","测试方法","测试原则","测试模型","测试对象"]
categories: ["TP311 程序设计、软件工程"]

hiddenFromHomePage: false
hiddenFromSearch: false
ruby: true
fraction: true
fontawesome: true
linkToMarkdown: true
rssFullText: false

---

## 一、软件测试定义

### 1.1 经典定义

1979，Myers，《软件测试艺术》

* 测试是为发现错误而执行程序的过程。
* 理解：

  * 测试是为了证明程序有错，而不是证明程序无错误。
  * 一个成功的测试是发现了至今未发现的错误的测试。

### 1.2 标准定义

1983，IEEE

* 使用人工或自动手段来运行或测定某个系统的过程，其目的在于检验它是否满足规定的需求或是弄清预期结果与实际结果之间的差别。
* 理解：

  * 测试是在用户需求和开发技术之间找一个平衡点。

### 1.3 国内定义

GB/T 11457

* 依据规范的软件检测过程和检测方法，按照测试计划和测试需求对被检测软件的文档、程序和数据进行测试的技术活动。

  * 软件测试是一个过程，测试不只是测试执行，它包括从计划开始到测试结束的一系列活动。
  * 软件测试需要测试方法和技术，或者说技巧。
  * 软件包括程序、数据和文档，除了执行程序，数据和文档也需要测试。

### 1.4 其他理解

不同时期关于测试的其他定义

* 确信程序做了它应该做的事(Hetzel,1973)。
* 确认程序正确实现了所要求的功能。
* 查出规格说明中错误，以及与规格说明不符的地方。
* 测试是一切以评价程序或系统的属性、能力为目的的活动；测试是对软件质量的度量(Hetzel,1983)。
* 评价程序或系统的过程。
* 测试是与软件开发或维护工作并行进行的一个过程。
* 测试是一个获取信息，降低决策风险的过程。通过测试，向整个团队提供关于产品质量和项目环境的信息，帮助他们做出决定。

---

## 二、软件测试方法分类

### 2.1 按测试阶段划分

#### 2.1.1 单元测试（Unit Testing）

**概念：** 针对被测系统最小的组成单元实施的测试活动，一般是类或函数，也可能是最小的功能单元。

又称模块测试、对软件的组成单位进行测试。比如：注册、登录、退出等单个功能。

**目的：** 检验软件基本组成单位的正确性。

#### 2.1.2 集成测试（Integration Testing）

**概念：** 针对组件/单元与组件/单元之间的接口实施的测试活动，验证接口设计是否与设计相符

又称联合测试（联调）、组装测试，将程序模块采用适当的集成策略组装起来，对系统的接口或集成后的功能进行正确性的检测。比如注册+登录功能联合起来测试。

**目的：** 检查软件之间的接口是否正确。

功能、非功能测试多用于集成测试；黑白盒相结合；自上而下，自下而上

**分类：**

* 函数间集成
* 模块间集成
* 子系统间集成

#### 2.1.3 系统测试（System Testing）

**概念：** 将通过集成测试的软件，部署在真实的用户环境下执行测试。

将软件看成一个系统的测试，包括对功能、性能以及软件运行的软硬件环境进行测试。

时间大部分在系统测试执行阶段，包括回归测试和冒烟测试

* 回归测试：多轮、反复
* 冒烟测试：软件测试前，对整体功能测试，看是否顺畅

#### 2.1.4 验收测试（Acceptance Testing）

**概念：** 以用户为主的测试，验收组应该由项目组成员、用户代表组成。

也称交付测试，软件部署之前的最后一个测试操作，技术测试的最后一个阶段，向软件购买者展示该软件是否满足原始需求。

**分类：**

* α测试：内部人员测，不属于用户的验收
* β测试：用户测，已投放给用户
* UAT测试：用户接受度测试

  一般商业用户验证系统可用性进行的测试

### 2.2 按是否查看代码划分

#### 2.2.1 黑盒测试（Black-Box Testing）

——主要应用于系统测试阶段

**概念：** 也称功能测试，不关心内部结构，只关心软件的输入数据和输出数据。

包括等价类划分法，边界值分析法，功能分解法，场景法等，属于动态测试

#### 2.2.2 灰盒测试（Gray-Box Testing）

——主要应用于集成测试阶段

**概念：** 介于黑白盒之间，黑白盒相结合的测试方法，多用于集成测试阶段，不仅关注输入、输出的正确性，同时也关注程序内部的情况。

#### 2.2.3 白盒测试（White-Box Testing）

——主要应用于单元测试阶段

**概念：** 又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试，需要研究源代码和程序结果。

白盒测试关注的是测试用例执行的程度或覆盖程序逻辑结构（源代码）的程度。

### 2.3 按是否运行划分

#### 2.3.1 静态测试

**概念：** 不运行被测试程序本身，仅通过分析或检查源程序的语法，结构，过程，接口等来检测程序的正确性，对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。

通常为开发内部对代码进行的评审。

#### 2.3.2 动态测试

**概念：** 通过运行被测程序，检查运行结果和预期结果的差异。

### 2.4 按是否自动化划分

#### 2.4.1 手工测试（Manual Testing）

**概念：** 是由人一个一个地输入用例，然后观察结果，和机器测试相对应，比较原始但是必须的一种测试方法，结果都需要人为收集或设计。

优点：不可替代，占比大。

缺点：工作量大、重复多、回归实现难。

#### 2.4.2 自动化测试（Automation Testing）

**概念：** 在预设条件下运行系统或应用程序，评估运行结果。

预设条件包括：正常条件和异常条件

人为驱动→机器执行（例：QTP工具）

### 2.5 按测试对象划分

#### 2.5.1 非功能测试（Non-Functional Testing）

##### 性能测试（Performance Testing）

通过模拟被测对象运行业务压力或使用场景，验证被测对象是否满足预先设定的性能指标。

关注点：

* 验证系统是否具有宣称的能力
* 了解测试系统典型场景，并具有确定的性能目标
* 要求在真实环境下实验​

##### 安全测试（Safety Testing）

测试被测对象的安全保护机制保护系统不受非法侵入，能够接受正确授权的操作。

##### 兼容性测试（Camptibility Testing）

验证被测对象在不同的操作系统、硬件信息等环境下的运行情况。

关注点：

* 平台测试
* 浏览器测试
* 软件本身能否向前或向后兼容

  * 2.0兼容1.0适配3.0
* 测试软件能否与其它相关软件兼容
* 数据兼容性测试

  * 不同设备数据同步

##### 文档测试（Document Testing）

开发文件：软件需求说明书、可行性研究报告、数据要求说明书、概要设计说明书、详细设计说明书、数据库设计说明书、模块开发卷宗

用户文件：

* 用户手册、操作手册
* 用户文档的作用：改善易安装性；改善软件的易学性与易用性；改善软件可靠性；降低技术支持成本
* 在实际的测试中，最常见的就是用户文件的测试，例如：用户操作说明书等

管理文件：测试计划、测试分析报告、项目开发计划、开发进度月报、项目开发总结报告

关注点：

* 文档的术语
* 文档的正确性

  * 错别字、语句不通顺
* 文档的完整性

  * 是否记录了所有功能
* 文档的一致性

  * 描述内容是否一致
* 文档的易用性

  * 通俗易懂

##### 用户体验性测试（User Ability Testing）

即易用性，易用性是交互的适应性、功能性和有效性的集中体现。

##### 界面测试（User Interface Testing）

简称UI测试。测试用户界面的功能模块的布局是否合理、整体风格是否一致、各个控件的放置位置是否符合客户使用习惯，此外还要测试界面操作便携性、导航简单易懂性，页面元素的可用性，界面中文字是否正确，命名是否统一，页面是否美观，文字、图片组合是否完美等。

##### 安装测试（Installation Testing）

测试程序的安装、卸载。

#### 2.5.2 功能测试（Functional Testing）

**概念：** 在指定使用条件下，使用被测对象，验证其是否满足用户显性或隐性需求。

**关注点：**

* 是否有不正确或遗漏或多余的功能
* 满足系统显性或隐性需求
* 是否对输入输出做出了正确的响应，输出结果能否正确的显示

按照所有测试用例对软件执行功能，检查是否满足用户的操作，包括各种异常表现。

### 2.7 按测试实施组织划分

#### 2.7.1 α测试（Alpha Testing）

**概念：** 指软件开发内部人员开始试用新产品。在实际运行环境和真实应用过程中发现测试阶段所没有发现的缺陷。经过 **Alpha测试和修正的软件产品称为Beta版本。**

注：

1. 内部人员一般指的是软件开发人员
2. Alpha测试为白盒测试，即根据内部结构图测试。
3. Alpha测试先于Beta（β）测试

#### 2.7.2 β测试（Beta Testing）

**概念：** 公司外部的典型用户试用，并要求报告异常情况，提出批评意见，然后再对Beta版本进行修正和完善，最终得到正式发布的版本。

注：

1. 外部的典型用户，例如即将上线的某游戏公测，其会给一些游戏主播资格试玩，然后根据他们游戏过程中体验以及发现的错误来进行修改完善。
2. 游戏主播无需知道游戏代码，以及内部结构就可以测试，故Beta（β）测试属于黑盒测试。

#### 2.7.3 α测试（Alpha Testing）与 β测试（Beta Testing）区别

**测试场所：**

* α是将用户请到开发方场所来测试
* β是在一个或多个用户的场所进行测试

**测试环境：**

* α测试环境受开发方控制，用户数量较少，时间较集中
* β测试环境不受开发方控制，用户数量较多，时间不集中

**测试周期：** 

* α先于β执行，β测试周期较长

#### 2.7.4 第三方测试（Third-patry Testing）

* 中国物理科学研究院
* 蒲公英等

---

## 三、软件测试原则

### 3.1 《软件测试的艺术》

#### 原则1：测试用例中一个必须部分是对预期输出或结果进行定义

一个测试用例必须包括两个部分：

1. 对程序的输入数据的描述。
2. 对程序在上述输入数据下的正确输出结果的精确描述。

#### 原则2：程序员应避免测试自己编写的程序

大多数程序员都不能有效地测试自己编写的程序，因为他们无法改变思维方式来尽力暴露自己程序中的错误。

#### 原则3：编写软件的组织不应当测试自己编写的软件

测试过程可能被认为降低了项目完成进度和成本目标，因此编程组织难以客观地测试自己的软件。

#### 原则4：应当彻底检查每个测试的执行结果

#### 原则5：测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况

针对未预料到的和无效输入情况的测试用例，比针对有效输入情况的用例更能发现问题。

#### 原则6：检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”

#### 原则7：应避免测试用例用后即弃，除非软件本身就是一个一次性的软件

保留测试用例，当程序其他部件发生变更后重新执行，这也就是所谓的“回归测试”。

#### 原则8：计划测试工作时不应默许假定不会发现错误

所谓测试，就是为发现错误而执行程序的过程。

#### 原则9：程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比

错误总是倾向于聚集存在。

#### 原则10：完全测试是不可能的，测试需要终止

### 3.2 其他软件测试原则

#### 原则1：所有的测试都应追溯到用户需求

缺陷的源头：根据相关调查，软件缺陷出现最多的地方是软件需求规格说明书（即软件需求定义），而不是程序代码。

如何应用此原则：

* 测试第一个任务是需求分析
* 测试需求分析要做好
* 时刻都要提醒自己考虑用户需求
* 制造缺陷的罪魁祸首不是程序员
* 做好需求评审

  * 审查所做的内容是否符合用户的需求

#### 原则2：尽早启动测试工作

如何应用此原则：

* 测试应该早进行。
* 测试应该是与软件开发或维护工作并行进行的一个过程，测试应该持续进行。

#### 原则3：早做测试计划

如何应用此原则：

* 软件测试不仅仅是测试执行。
* 应该在测试工作真正开始前的较长时间内就进行测试计划。

#### 原则4：穷尽测试不可能 & 软件测试有风险

无法穷尽测试的主要原因：测试数据输入量太大、时间不够等。

如何应用此原则：

* 如果决定不去测试所有的情况，那么我们就面临了很大的风险。
* 如果时间不够，无法进行充分的测试怎么办?
* 使用风险分析，确定测试的重点和优先级，控制测试的开销（时间、成本、资源）。
* 风险分析需要判断技能、常识、感觉和经验

#### 原则5：测试工作的 Good-enough 原则

含义：既不要做过多测试，也不做不充分的测试。

如何应用此原则：解决办法是通过需求分析和风险分析（时间、费用、资源）找到测试重点，制定最低测试通过标准和测试内容，然后具体问题具体分析。

#### 原则6：Pareto 法则应用于软件测试

含义：Pareto（帕累托）法则由意大利经济学家帕累托提出，又称为 28 效率法则。

* 一般情况下 80％的缺陷聚集在 20％的关键核心业务模块中。
* 在分析、设计、实现阶段的复审和测试工作能够发现和避免 80%的缺陷，而系统测试又能找出其余缺陷中的 80%，最后的 4%的缺陷可能只有在用户的大范围、长时间使用后才会曝露出来。

如何应用此原则：

* 做好测试需求分析和测试计划，分清测试重点。
* 尽早测试。
* 持续测试

#### 原则7：尽可能使用分阶段测试

单元测试→集成测试→系统测试→验收测试（代码规模不断加大）。

#### 原则8：为了达到最佳效果，应该由独立的第三方来构造测试

“最佳效果”指最有可能发现错误的测试。

* 程序员从来都不会承认自己写的程序有错误。
* 程序员测试自己的编码是一件很糟糕的事，但是让他们测试别人的编码却成了最好的测试人员。
* 程序员的测试思路有明显的局限性。
* 多数程序员没有经过严格正规的职业训练。
* 程序员无良好的 BUG 跟踪和回归测试习惯。

#### 原则9：测试旨在发现存在的缺陷

软件测试可以报告软件缺陷存在，却不能报告软件缺陷不存在；既使在测试过程未发现软件的失效，也不能证明被测软件没有错误。

#### 原则10：为了保证测试的有效性和高效性，测试必须是破坏性、系统化的

充分、有效、系统的测试可以减少软件中未被发现缺陷的可能性；测试既要验证软件的正确性，更要通过破坏软件，发现缺陷的不正确性。

#### 原则11：找到的软件缺陷越多，说明软件隐含的缺陷越多

缺陷具有群集效应。应该在发现缺陷的地方继续找找。

#### 原则12：杀虫剂怪事

用于描述软件测试越多，其对测试的免疫力越强的现象。为了克服杀虫剂怪事，软件测试员必须不断编写不同的、新的测试程序，对程序的不同部分进行测试，以找出更多软件缺陷。

#### 原则13：并非所有软件缺陷都要修复

1. 没有足够的时间；
2. 不算真正的软件缺陷；
3. 修复的风险太大；
4. 不值得修复。

#### 原则14：使用木桶原理

木桶原理在软件产品生产方面就是全面质量管理（QTM）的概念。

#### 原则15：前进两步，后退一步

测试中的一个基本问题是——缺陷修复总会以（20-50）%的机率引入新的缺陷。每次修复之后，必须做确认测试和回归测试。

* 再测试/确认测试

  * 测试人员提交缺陷，开发人员修复缺陷以后，测试人员需要重新测试，验证之前的提交的缺陷是否真正修复。
* 回归测试

  * 测试人员提交缺陷，开发人员修复缺陷以后，测试人员需要重新测试，确保对程序修改改没有给软件其他未改变部分带来新的缺陷。软件修改或者环境变更后，必须进行回归测试。

#### 原则16：软件测试是一个迭代的过程

无论项目采用何种开发模型，测试人员总是一个版本接一个版本地测试，其测试活动总是迭代向前的

* 测试版本 1->提交缺陷->修复缺陷->测试版本 2->提交新缺陷->修复新缺陷->测试版本 3->…

#### 原则17：测试需要遵循标准

什么是标准

* 你家的某个电器或家具脱落了一个螺丝钉，你可能会很随意地到街市买一个回家安上，这说明什么——制造业的标准在起作用。家用电器是依据标准制造的，所以随之而来的各种标准配件也会很容易找到。

标准的分类：

* 国际标准：如 ISO、CMM（Capability Maturity Model，软件能力成熟度模型）、IEEE（国际电气电子工程师协会）
* 国家标准：GB、GB/T
* 行业标准
* 公司标准
* 用户规定

#### 原则18：其他的一些测试理念

* 思路决定测试
* 具体问题具体分析
* 无责任心不成测试
* 测试不能靠猜测

---

## 四、软件测试策略

一组合理的策略如下：

1. 如果规格说明中包含输入条件组合的情况，应首先使用因果分析方法
2. 在任何情况下都应使用边界值分析法。应记住，这是对输入和输出边界进行的分析。边界值分析可以产生一系列补充的测试条件，但是多数甚至全部条件都可以被整合到因果图分析中
3. 应为输入和输出确定有效和无效等价类，在必要情况下对上面确认的测试用例进行补充
4. 使用错误猜测技术增加更多的测试用例
5. 针对上述测试用例集检查程序的逻辑结构。应使用判定覆盖、条件覆盖、判定/条件覆盖或多重条件覆盖准则（最后的一个最为完整）。如果覆盖准则未能被前四个步骤中确定的测试用例所满足，并且满足准则也并非不可能（由于程序的性质限制，某些条件的组合也许是不可能实现的），那么增加足够数量的测试用例，以使覆盖准则得到满足

---

## 五、软件测试模型

### 5.1 软件产品质量模型（ISO/IEC9126）

定义：软件质量，就是软件与明确地和隐含地定义得需求相一致得程度。

功能性：

* 是指软件产品在指定条件下使用时，提供满足明确和隐含要求的功能的能力。
* 包含：适合性、准确性、互操作性、保密安全性

可靠性：

* 是指在特定条件下使用时，软件产品维持规定的性能级别能力。
* 包含：成熟性、容错性

易用性 ：

* 是指用户在指定条件下使用软件产品时，产品被用户理解、学习、使用和吸引用户的能力。
* 包含：易理解性、易学性、易操作性、吸引性

效率性：

* 是指在规定条件下，相对于所用资源的数量，软件产品可提供适当的性能的能力。
* 包含：时间特性、资源利用性

可维护性：

* 是指产品可被修改的能力。这里的修改是指软件产品和软件产品对环境、功能规格变化的适应性。
* 包含：易分析性、易改变性、稳定性、易测试性

可移植性：

* 是指软件产品从一种环境迁移到另外一种环境的能力。这里的环境是指硬件、软件或组织等不同的环境。
* 包含：适应性、易安装性、共存性、易替换性

### 5.2 软件测试过程模型

#### 5.2.1 V模型

![](https://api2.mubu.com/v3/document_image/41669bf2-0ca0-413d-aab8-570181540ea8-1992406.jpg)

**优点：**

1. 测试策略既包含了底层测试（单元测试）又包括了高层测试（系统测试），底层测试是为了源代码正确性，高层测试是为了使整个系统满足用户的需求。
2. 清楚的标识了开发和测试的各个阶段。
3. 自上而下逐步求精，每个阶段分工明确，便于整体项目的把控。

**缺点：**

1. 自上而下的顺序导致了测试工作在编码之后，就导致错误不能及时地进行修改
2. 实际工作中，需求经常变化，导致v模型步骤，反复执行，返工量很大，灵活度较低

#### 5.2.2 W模型
![](https://api2.mubu.com/v3/document_image/56fb9796-e390-46f3-8c2d-641b214a61d7-1992406.jpg)

**优点：**

1. 更早地接入测试，可以发现开发初期的缺陷，那么可以用更加低的成本进行缺陷修复。
2. 同样是分阶段的工作，便于控制项目过程。

**缺点：**

1. 依赖于软件开发和软件测试依然保持一前一后的线性关系，依然无法支持迭代、自发性和需求等变更调整。
2. 对于当前很多项目，在执行的过程中根本不产生文档，那么W模型基本无法适用。
3. 使用起来技术复杂度很高，对于需求和设计的测试要求很高，实践起来困难。

#### 5.2.3 H模型

![](https://api2.mubu.com/v3/document_image/d2c49a9c-b416-48a7-8527-3516d7a61b01-1992406.jpg)

**优点：**

1. 软件测试完全独立，贯穿整个生命周期，且与其他流程并发进行
2. 软件测试活动可以尽早准备、尽早执行，具有很强的灵活性
3. 软件测试可以根据被测物的不同而分层次、分阶段、分次序的执行，同时也是可以被迭代的

**缺点：**

1. 管理型要求高
2. 技能要求高
3. 测试就绪点分析困难
4. 对于整个项目组的人员要求非常高

---

## 六、软件测试对象

* 软件源代码
* 与软件源代码匹配的文档
* 支撑软件源代码运行的配置数据
* 需求阶段

  * 需求文档

    * 测试需求文档是否正确实现了用户的需求
* 系统设计阶段

  * 概要设计文档
  * 详细设计文档
  * 是否有设计或逻辑上的错误
* 编码阶段

  * 测试源代码

    * 发现编程上的错误
* 系统测试阶段

  * 被测对象是否满足用户需求

